---
title: "Capsella rubella introgression to Capsella bursa-pastoris populations"
author: "Maya Wilson Brown"
date: "2024-02-20"
output: html_document
---
```{r}
library(ggplot2)
library(ggrepel)
library(tidyr)
library(stringr)
library(dplyr)
library(rnaturalearth) # for maps
library(scico) # colors
```

I have written functions for the plots I want and selecting K.
We can source the functions from capsella_pop_introgression_functions.R
```{r load functions}
source("~/Documents/PhD/Research/capsella_population_structure/capsella_pop_def_functions.R")
```

```{r directory variables}
# load data directory
admix_dir <- "~/Documents/PhD/Research/capsella_population_structure/data/"
temp_plot <- "~/Documents/PhD/Research/capsella_population_structure/temp_plots/"
plot_dir <- "~/Documents/PhD/Research/capsella_population_structure/plots/"
```

```{r capsella sequenced information}
# load information about samples
vcf_dat <- read.csv("~/Documents/PhD/Research/capsella_sample_info/generated_mkwb/Capsella_vcf_metadata.txt", sep = "\t", header = T)
```

# Colors
Just setting up some colors
```{r, eval=F}
# roma
"#7E1700" "#AC7726""#88D9D7" "#023198"
# Roma (geographic regions)
"#7E1700" "#B58B31" "#C0E9C2" "#389CC6" "#023198"

# vik
"#001260" "#71A7C4" "#D29773" "#590007"

# Roma (geographic regions)
region.cols <- c("E. Asia" = "#7E1700", "MENA/Medditeranean"= "#B58B31", "N. Europe"= "#C0E9C2", "US"= "#389CC6","C.Asia"="#023198")


# Hawaii (populations) -- chosen
pop.cols <- c("E_Asia" = "#8C0172", "MENA"= "#996330", "N_Europe"= "#7FC55F", "NYC"= "#B2F2FD")

#managua
"#FFCE66" "#92463A" "#4D5492" "#80E6FF"


# Bursa-pastoris to rubella range (vanimo)
"#FFCCFD" "#5B244E" "#354819" "#BEFDA5"

"#FFCCFD" "#BC62A8" "#1A1412"  "#6D9636" "#BEFDA5"


#glasgow (geographic regions)
#scico(5, palette = 'glasgow')
#region_cols <- c("C. Asia" = "#351338", "E. Asia" = "#7E1700", "MENA/Medditeranean" = "#B58B31", "N. Europe" ="#69A3A5", "US" ="#DAD2FF") #super dull on white bg

# Roma (geographic regions)
region.cols <- c("E. Asia" = "#7E1700", "MENA/Medditeranean"= "#B58B31", "N. Europe"= "#C0E9C2", "US"= "#389CC6","C.Asia"="#023198")


# Hawaii (populations) -- chosen
pop.cols <- c("E_Asia" = "#8C0172", "MENA"= "#996330", "N_Europe"= "#7FC55F", "NYC"= "#B2F2FD")


```

# Capsella bursa-pastoris Principle Components -- All Populations
```{r pca eigenstuff}
# read in eigenvec and eigenval data
vec <- read.csv(paste0(admix_dir, "all_pruned_cbp.eigenvec"), sep = "\t", header = T) #values on each PC

val <-  read.csv(paste0(admix_dir, "all_pruned_cbp.eigenval"), sep = "\t", header = F) #PC variances explained


# percantage of variance explained by each PC
percentage <- round((val/(sum(val))*100), 2)
percentage <- as.matrix(percentage)
percentage <- paste0(names(percentage), " (", percentage, "%)")
```

```{r join pca with meta}
# match individual IDs to informative data
pc_info <- left_join(vec, vcf_dat, join_by("X.IID" == "vcf_sample_name"))

# make continent column?
pc_info <- pc_info %>% mutate(region = case_when(country %in% c("Switzerland","Iceland","Netherlands","Poland","Germany","Sweden","United Kingdom","France") ~ "N. Europe",
                                      country %in% c("Spain", "Greece", "Italy","Jordan", "Algeria","Turkey") ~ "MENA/Medditeranean",
                                      country %in% c("Kyrgyzstan", "Russia") ~ "C. Asia",
                                      country %in% c("China", "Taiwan") ~ "E. Asia",
                                      country == "United States" ~ "US"))
```

```{r pc1_pc2}
# rough plot
pc_plot1 <- ggplot() +
  geom_point(data=pc_info, aes(x=PC1, y=PC2, color = region)) +
  geom_text_repel(data=subset(pc_info, sample_name %in% c("wt-msu", "KYRG-3-14", "WAC5", "HRB132", "FY5", "BEJ3", "TACH1", "TACH_CHIN14")), aes(x=PC1, y=PC2, label = sample_name), size = 2) +
  scale_color_manual(values = region.cols) +
  theme_bw() +
  labs(x=paste0("PC1",percentage[1]), y= paste0("PC2",percentage[2]))

pc_plot1
```

```{r}
# save plot
ggsave(paste0(temp_plot, "all_cbp_pca1.png"), pc_plot1, height = 5, width = 8)
```


Check out the other PCs
```{r pc1_pc3}
# rough plot
pc_plot2  <- ggplot() +
  geom_point(data=pc_info, aes(x=PC1, y=PC3, color = region)) +
  geom_text_repel(data=subset(pc_info, sample_name %in% c("wt-msu", "KYRG-3-14", "WAC5", "HRB132", "FY5", "BEJ3", "TACH1", "TACH_CHIN14")), aes(x=PC1, y=PC3, label = sample_name), size = 2) +
  theme_bw() +
  labs(x=paste0("PC1",percentage[1]), y= paste0("PC3",percentage[3]))


#plot it
pc_plot2
# save plot
ggsave(paste0(temp_plot, "all_cbp_pca2.png"), pc_plot2, height = 5, width = 8)
```

It seems like PC1 largely captures the US and Northern Europe population separating out from everyone else, and PC2 is picking up on the Mediterranean populations.

Now let's look within NY.
```{r pca eigenstuff}
# read in eigenvec and eigenval data
vec <- read.csv(paste0(admix_dir, "nyc_pruned_cbp.eigenvec"), sep = "\t", header = T) #values on each PC

val <-  read.csv(paste0(admix_dir, "nyc_pruned_cbp.eigenval"), sep = "\t", header = F) #PC variances explained


# percantage of variance explained by each PC
percentage <- round((val/(sum(val))*100), 2)
percentage <- as.matrix(percentage)
percentage <- paste0(names(percentage), " (", percentage, "%)")
```

```{r join pca with meta}
# match individual IDs to informative data
pc_info <- left_join(vec, vcf_dat, join_by("X.IID" == "vcf_sample_name"))
```

```{r}
# rough plot
nyc_pc_plot1 <- ggplot() +
  geom_point(data=pc_info, aes(x=PC1, y=PC2, color = city)) +
  geom_text_repel(data= pc_info, aes(x=PC1, y=PC2, label = population), size = 2) +
  theme_bw() +
  labs(x=paste0("PC1",percentage[1]), y= paste0("PC2",percentage[2]))

nyc_pc_plot1
```

Save image
```{r}
# save plot
ggsave(paste0(temp_plot, "nyc_cbp_pca1.png"), nyc_pc_plot1, height = 5, width = 8)
```

For NYC, PC1 is capturing variation driven by population 24 (New Jersey), while pc2 is capturing variation driven by population 14 (Jerico).

# Capsella population admixture results and cluster assignment
Plotting and recording the admixture analysis in *Capsella bursa-pastoris* for analyzing group differences in introgressed regions

Load in the ADMIXTURE output data
```{r import admixture output files}
# read in the PLINK fam file which has the sample name information in the same order as the admixture output files
cbp_fam <- read.delim(paste0(admix_dir, "all_pruned_cbp.fam"), header=FALSE)

# list the files in admixture directory matching suffix pattern
lst <- list.files(path = admix_dir, pattern = "all_pruned_cbp.[0-9]+.Q") # Q files are ancestry fractions for each sample

cbp_ancestry_propsK <- list()  # Create an empty list to store the data for each iteration of K groups
#loop to load sample data
for (file in lst) {
  file_path <- file.path(admix_dir, file)  # Get the full file path
  cbp_ancestry_propsK[[file]] <- read.table(file_path, header = F)  # Read the file and store in the list
}
```

```{r}
# create sample name key from fam file 
cbp_name_key <- left_join(data.frame(cbp_fam$V2), vcf_dat[,c("vcf_sample_name", "sample_name")],
                         join_by("cbp_fam.V2" == "vcf_sample_name"))
colnames(cbp_name_key)[1] <- "vcf_sample_name"

# bind fam file to all ADMIXTURE files
#ea_p <- lapply(ea_ancestry_propsK, transform, vcf_sample_name=ea_fam$V2)
cbp_p <- Map(cbind, cbp_ancestry_propsK, list(cbp_name_key))

# name list elements by the K groups they represent
names(cbp_p) <- paste0("K",str_extract(names(cbp_p), "[0-9]+"))
rm(cbp_ancestry_propsK)
```


Now to look at the cross validation error rates
```{r cv_error K groups}
# read in Cross Validation (cv) error log
cbp_cv <- read.delim(paste0(admix_dir, "all_cbp_cv_error.log"), header = FALSE, sep = ":")
# extract K groups from string
cbp_cv$K_groups <- str_extract(cbp_cv$V1, "[0-9]+")

# Plot
plotK(cbp_cv)
```


Looks like K = 4 has the lowest CV error rate. This makes sense considering we expect about three groups in the ancestral range, plus NYC.
```{r}
# make ancestry bars plot
#cap_k3 <- ancestry_bars(cap_ancestry_propsK, K = K, sample_names_fam=cap_fam, ggplot_opt = scale_fill_manual(values = c("pop1" = "#4DBBD5FF", "pop2" = "#E64B35FF", "pop3" = "orchid1")))

cap_k4 <- ancestry_bars2(cbp_p, "K4")
# plot
cap_k4

```

```{r save cbp image}
# save image
ggsave(paste0(temp_plot,"cbp_k4.png"), cap_k4, width = 13, height = 7, units = "in")
```


#### ADMIXTURE conditioned on K

If we just think about ADMIXTURE and STRUCTURE as ways to select a valuable K number of ancestral groups, it makes sense to run admixture on the Eurasian C. bursa-pastoris samples on their own, and select the best K groups from the ancestral population. Then, using that K, I would run ADMIXTURE on only the NYC populations and assign the NYC population to those K ancestral groups. I am not sure of the best way to match between the populations, but I may just have to look at the allele frequencies in the inferred ancestral populations and match them that way.

I do feel that is analysis has already been done by Kryvohkhyzha and colleagues to some capacity.

```{r import admixture output files}
# read in the PLINK fam file which has the sample name information in the same order as the admixture output files
ea_fam <- read.delim(paste0(admix_dir, "eurasian_pruned_cbp.fam"), header=FALSE)

# list the files in admixture directory matching suffix pattern
lst <- list.files(path = admix_dir, pattern = "eurasian_pruned_cbp.[0-9]+.Q") # Q files are ancestry fractions for each sample

ea_ancestry_propsK <- list()  # Create an empty list to store the data for each iteration of K groups
#loop to load sample data
for (file in lst) {
  file_path <- file.path(admix_dir, file)  # Get the full file path
  ea_ancestry_propsK[[file]] <- read.table(file_path, header = F)  # Read the file and store in the list
}
```

```{r}
# create sample name key from fam file 
ea_name_key <- left_join(data.frame(ea_fam$V2), vcf_dat[,c("vcf_sample_name", "sample_name")],
                         join_by("ea_fam.V2" == "vcf_sample_name"))
colnames(ea_name_key)[1] <- "vcf_sample_name"

# bind fam file to all ADMIXTURE files
#ea_p <- lapply(ea_ancestry_propsK, transform, vcf_sample_name=ea_fam$V2)
ea_p <- Map(cbind, ea_ancestry_propsK, list(ea_name_key))

# name list elements by the K groups they represent
names(ea_p) <- paste0("K",str_extract(names(ea_p), "[0-9]+"))
rm(ea_ancestry_propsK)
```

```{r cv_error K groups}
# read in Cross Validation (cv) error log
ea_cv <- read.delim(paste0(admix_dir, "eua_cv_error.log"), header = FALSE, sep = ":")
# extract K groups from string
ea_cv$K_groups <- str_extract(ea_cv$V1, "[0-9]+")

# Plot
plotK(ea_cv)

# select K
#K = selectK(ea_cv)
```

```{r eurasian k2, eval=FALSE}
# data for k = 2 on Eurasian group
ea_k2 <- ancestry_bars2(ea_p, "K2")

#ggplot_opt = scale_fill_manual(values = c("pop1" = "#4DBBD5FF", "pop2" = "orange"))

# make just the plot show up
plot(ea_k2)

ggsave(paste0(temp_plot,"eurasian_cbp_k2.png"), ea_k2, width = 13, height = 7, units = "in")
```

Same but for K=3 and K=4
```{r}
# data for k = 2 on Eurasian group
ea_k3 <- ancestry_bars2(ea_p, "K3")
# make just the plot show up
plot(ea_k3)
ggsave(paste0(temp_plot,"eurasian_cbp_k3.png"), ea_k3, width = 13, height = 7, units = "in")
```

```{r}
# data for k = 2 on Eurasian group
ea_k4 <- ancestry_bars2(ea_p, "K4")
# make just the plot show up
plot(ea_k4)
ggsave(paste0(temp_plot,"eurasian_cbp_k4.png"), ea_k4, width = 13, height = 7, units = "in")
```

Same information largely, but on a map.

```{r assign ancestry}
# assign sample to majority ancestry
ea_k2_ancestry <- assign_ancestry(ea_p, "K2")

# join with location data
ea_k2_ancestryL <- left_join(ea_k2_ancestry, vcf_dat[c("vcf_sample_name","sample_name",
                                                 "longitude","latitude","latlong_approx")])
```

```{r}
# world map
ea_k2_map <- eurasia + geom_point(data=ea_k2_ancestryL, aes(x=longitude, y=latitude, fill = group, color = latlong_approx), shape=21, size = 7) #+
  #scale_fill_manual(name = "Group", values = c("pop1" = "#4DBBD5FF", "pop2" = "orange"), labels = c("East Asian", "European"))

ea_k2_map

ggsave(paste0(temp_plot, "eurasian_k2_bigDots.png"),ea_k2_map, width = 13, height = 7, units = "in")
```


```{r assign ancestry}
# assign sample to majority ancestry
ea_k3_ancestry <- assign_ancestry(ea_p, "K3")

# join with location data
ea_k3_ancestryL <- left_join(ea_k3_ancestry, vcf_dat[c("vcf_sample_name","sample_name",
                                                 "longitude","latitude","latlong_approx")])
```

```{r}
# world map
ea_k3_map <- eurasia + geom_point(data=ea_k3_ancestryL, aes(x=longitude, y=latitude, fill = group, color = latlong_approx), shape=21, size = 7) #+
  #scale_fill_manual(name = "Group", values = c("pop1" = "#4DBBD5FF", "pop2" = "orange"), labels = c("East Asian", "European"))

ea_k3_map

ggsave(paste0(temp_plot, "eurasian_k3_bigDots.png"),ea_k3_map, width = 13, height = 7, units = "in")
```
Suspicions confirmed: there are two main populations in the ancestral range; one is in southern and eastern Asia, while the other is mostly in Europe and northwestern China with some overlap.

Given the original population structure inferred at the very top of this document, this suggests a few things: 
- 2 populations / ancestry groups are most likely. The reason k=3 and k=4 show lower cross validation error rates is probably due to the European, northwestern Chinese cluster being overwhelmed by the number of New York individuals and *their* allele frequencies
- The European/ northwestern Chinese cluster at the top of the document appears largely admixed with a Mediterranean-like cluster. Again, that is probably not real population structure, but due to the New York City samples overwhelming the allele frequency patterns. Therefore, I suspect that there has been a mild bottleneck from the European population into New York and New Jersey.

K = 4 just out of curiosity

```{r}
# assign sample to majority ancestry
ea_k4_ancestry <- assign_ancestry(ea_p, "K4")

# join with location data
ea_k4_ancestryL <- left_join(ea_k4_ancestry, vcf_dat[c("vcf_sample_name","sample_name",
                                                 "longitude","latitude","latlong_approx")])
```

```{r}
ea_k4_map <- eurasia + geom_point(data=ea_k4_ancestryL, aes(x=longitude, y=latitude, fill = group, color = latlong_approx), shape=21, size = 7) 

ea_k4_map

ggsave(paste0(temp_plot, "eurasian_k4_bigDots.png"),ea_k4_map, width = 13, height = 7, units = "in")
```

From the **Projection analysis** section of the ADMIXTURE manual:
> ADMIXTURE now allows loading of learned allele frequencies from the .P files. For two
datasets with the same set of SNPs, clusters can be learned using the unsupervised mode
of ADMIXTURE on the first dataset; subsequently, the learned clusters and ancestry
proportions from the first dataset can be provided as input used to project the second
dataset with the -P option.
Example: Suppose reference.bed is the PLINK binary file containing reference panels
and study.bed is the PLINK binary file containing study samples. The following sequence
of commands can be used to learn population structure from the reference panel and project
the study individuals on it:
# Verify the two datasets have the same set of SNPs
% diff -s reference.bim study.bim
# Run unsupervised ADMIXTURE with K=2
% admixture reference.bed 2
# Use learned allele frequencies as (fixed) input to next step
% cp reference.2.P study.2.P.in
# Run projection ADMIXTURE with K=2
% admixture -P study.bed 2

>The projection approach is particularly useful when the study sample is much larger than
the reference panel. When the study sample is comparable in size to the reference panel,
it may be preferable to run unsupervised ADMIXTURE on the combined set since the
running time scales linearly with the number of samples.

>The same approach can also be used for inferring ancestry on a set of related individuals.
Pedigree information or existing methods such as PLINK [5], KING [6] or PRIMUS [7] can
be used to identify the largest subset of unrelated individuals in the dataset. ADMIXTURE
is then run unsupervised on the largest set of unrelated individuals (using that as the
reference set in the example above). The rest of the individuals (who can be related to the
reference set) can then be projected on the resulting population structure.

So that is pretty useful.

###### Plot results of projected admixtures
```{r import admixture output files}
# read in the PLINK fam file which has the sample name information in the same order as the admixture output files
nyc_fam <- read.delim(paste0(admix_dir, "nyc_pruned_cbp.fam"), header=FALSE)

# list the files in admixture directory matching suffix pattern
lst <- list.files(path = admix_dir, pattern = "nyc_pruned_cbp.[0-9]+.Q") # Q files are ancestry fractions for each sample

nyc_ancestry_propsK <- list()  # Create an empty list to store the data for each iteration of K groups
#loop to load sample data
for (file in lst) {
  file_path <- file.path(admix_dir, file)  # Get the full file path
  nyc_ancestry_propsK[[file]] <- read.table(file_path, header = F)  # Read the file and store in the list
}
```

```{r}
# create sample name key from fam file 
nyc_name_key <- left_join(data.frame(nyc_fam$V2), vcf_dat[,c("vcf_sample_name", "sample_name")],
                         join_by("nyc_fam.V2" == "vcf_sample_name"))
colnames(nyc_name_key)[1] <- "vcf_sample_name"

# bind fam file to all ADMIXTURE files
#nyc_p <- lapply(nyc_ancestry_propsK, transform, vcf_sample_name=nyc_fam$V2)
nyc_p <- Map(cbind, nyc_ancestry_propsK, list(nyc_name_key))

# name list elements by the K groups they represent
names(nyc_p) <- paste0("K",str_extract(names(nyc_p), "[0-9]+"))
rm(nyc_ancestry_propsK)
```

```{r eurasian k2, eval=FALSE}
# data for k = 2 on Eurasian group
nyc_k2 <- ancestry_bars2(nyc_p, "K2")

#ggplot_opt = scale_fill_manual(values = c("pop1" = "#4DBBD5FF", "pop2" = "orange"))

# make just the plot show up
plot(nyc_k2)

ggsave(paste0(temp_plot,"nyc_cbp_k2.png"), nyc_k2, width = 13, height = 7, units = "in")
```

Same but for K=3 and K=4
```{r}
# data for k = 2 on Eurasian group
nyc_k3 <- ancestry_bars2(nyc_p, "K3")
# make just the plot show up
plot(nyc_k3)
ggsave(paste0(temp_plot,"nyc_cbp_k3.png"), nyc_k3, width = 13, height = 7, units = "in")
```

Since the mapped plot of only NYC will not be that interesting, I will combine the Eurasian and NYC data frames to make a map.
```{r}
# assign majority ancestry to nyc data frames
nyc_k2_ancestry <- assign_ancestry(nyc_p, "K2")
nyc_k3_ancestry <- assign_ancestry(nyc_p, "K3")
nyc_k4_ancestry <- assign_ancestry(nyc_p, "K4")

# combine Eurasian and NYC data frames
k2_ancestry <- rbind(ea_k2_ancestry, nyc_k2_ancestry)
k3_ancestry <- rbind(ea_k3_ancestry, nyc_k3_ancestry)
k4_ancestry <- rbind(ea_k4_ancestry, nyc_k4_ancestry)

# join with location data
k2_ancestryL <- left_join(k2_ancestry, vcf_dat[c("vcf_sample_name","sample_name",
                                                 "longitude","latitude","latlong_approx")])
k3_ancestryL <- left_join(k3_ancestry, vcf_dat[c("vcf_sample_name","sample_name",
                                                 "longitude","latitude","latlong_approx")])
k4_ancestryL <- left_join(k4_ancestry, vcf_dat[c("vcf_sample_name","sample_name",
                                                 "longitude","latitude","latlong_approx")])


```

Final maps of this conditional clumping
```{r}
cond_k2_map <- world + geom_point(data=k2_ancestryL, aes(x=longitude, y=latitude, fill = group, color = latlong_approx), shape=21, size = 7) 

cond_k2_map

ggsave(paste0(temp_plot, "cond_k2_bigDots.png"),cond_k2_map, width = 13, height = 7, units = "in")
```

```{r}
cond_k3_map <- world + geom_point(data=k3_ancestryL, aes(x=longitude, y=latitude, fill = group, color = latlong_approx), shape=21, size = 7) 

cond_k3_map

ggsave(paste0(temp_plot, "cond_k3_bigDots.png"),cond_k3_map, width = 13, height = 7, units = "in")
```

```{r}
cond_k4_map <- world + geom_point(data=k4_ancestryL, aes(x=longitude, y=latitude, fill = group, color = latlong_approx), shape=21, size = 7) 

cond_k4_map

ggsave(paste0(temp_plot, "cond_k4_bigDots.png"),cond_k4_map, width = 13, height = 7, units = "in")
```
With all of the above plots, the East Asian population always stands out. There is evidence that there is more continuous structure or some sort of gradient moving from the Mediterranean region, through central Asia (Kyrgyzstan).

This is also good evidence that we can use some individuals from the East Asian group as a parental population in the local ancestry inference.

Regardless of whether K=2,3, or 4, there are always 33 individuals that are in the East Asian cluster with no admixture present. I think it makes sense to use 25-30 individuals as the parental group in the LAI, and verify there's no inferred *C. rubella* ancestry with the rest.

# NYC and European with/out MENA 
Seeing as the NYC individuals seems to clearly have a lot of shared variation with the Northern European group, it is worth seeing how NYC individuals partition into this group.

I think given the number of NYC individuals, I may try to condition their admixture proportions on Northern European alone. I am not sure how useful it would be to see the NYC individuals form their own cluster, but I will run that as well.

**NOTE:** Originally, I included Mediterranean/Middle Eastern,North African individuals in the analysis, but it became clear that was not useful or informative since they form their own cluster quite removed from the N. Europe and NYC individuals.

For the following analyses, I only include samples that have majority N. European ancestry when K=3 in the ancestral range with individuals from New York and New Jersey.

Plan:
- PCA with NYC + N. Europe
- Admixture in NYC conditioned on allele frequencies in N. EU + Mena (K=1,2,3,4,5)
- Admixture free on NYC + N.EU (to see if the CV error rates suggest NYC wants to cluster on its own)
  - if NYC does cluster on its own freely with N.EU, that *could* suggest there's been quite a bit of allele frequency change across continents **OR** the NYC group is just large and it popping out as its own cluster could be an artifact of over fitting (? but I really do not know if that matters and would have to look at the documentation for ADMIXTURE)

```{r select Euro group}
# select individuals whose ancestry is not the East Asian group: pop1 when k=3
nEU <- ea_k3_ancestry[which(ea_k3_ancestryL$group == "pop1"),]

# remove wt-msu because of the way PC3 in the whole CBP PCA draws 3 of them out
nEU <- nEU[which(nEU$sample_name != "wt-msu"),]
```

```{r}
#save and write files
write.table(nEU$vcf_sample_name, file = "~/Documents/PhD/Research/capsella_population_structure/vcf_neu.txt", quote = F, row.names = F, col.names = F, sep = "\t")
```

# Northern European & NYC Plots

Starting with PCA of NYC with N. European group (minus wt-msu).

```{r pca eigenstuff}
# read in eigenvec and eigenval data
vec <- read.csv(paste0(admix_dir, "nyc_neu/nyc_neu_pruned.eigenvec"), sep = "\t", header = T) #values on each PC

val <-  read.csv(paste0(admix_dir, "nyc_neu/nyc_neu_pruned.eigenval"), sep = "\t", header = F) #PC variances explained


# percantage of variance explained by each PC
percentage <- round((val/(sum(val))*100), 2)
percentage <- as.matrix(percentage)
percentage <- paste0(names(percentage), " (", percentage, "%)")
```

```{r join pca with meta}
# match individual IDs to informative data
pc_info <- left_join(vec, vcf_dat, join_by("X.IID" == "vcf_sample_name"))
```

```{r}
# rough plot
nyc_neu_pc_plot1 <- ggplot() +
  geom_point(data=pc_info, aes(x=PC1, y=PC2, color = country)) +
  theme_bw() +
  labs(x=paste0("PC1",percentage[1]), y= paste0("PC2",percentage[2])) +
  geom_text_repel(data=subset(pc_info, country != "United States"), aes(x=PC1, y=PC2, label = sample_name), max.overlaps = 50, size = 2)

nyc_neu_pc_plot1
```
PC1 seems to separate some of the Chinese plants from the rest, while PC2 clusters mainland Europe from others.

Save image
```{r}
# save plot
ggsave(paste0(temp_plot, "nyc_neu_cbp_pca1.png"), nyc_neu_pc_plot1, height = 5, width = 8)
```

I would lke to zoom in on that cluster
```{r}
nyc_neu_pc12_zoom <- ggplot() +
  geom_point(data=subset(pc_info, country %in% c("United States", "Netherlands", "Poland", "Russia", "Sweden")), aes(x=PC1, y=PC2, color = country)) +
  theme_bw() +
  labs(x=paste0("PC1",percentage[1]), y= paste0("PC2",percentage[2])) +
  geom_text_repel(data=subset(pc_info, country %in% c("United States", "Netherlands", "Poland", "Russia", "Sweden")), aes(x=PC1, y=PC2, label = sample_name), max.overlaps = 50, size = 2)

# save plot
#ggsave(paste0(temp_plot, "nyc_neu_pca1_zoom.png"), nyc_neu_pc12_zoom, height = 5, width = 8)
```
Looks East to West (PC1) and North to South (PC2)?

We can check that
```{r}
nyc_neu_pc1Long_zoom <- ggplot() +
  geom_point(data=subset(pc_info, country %in% c("United States", "Netherlands", "Poland", "Russia", "Sweden")), aes(x=longitude, y=PC1, color = country)) +
  theme_bw() +
  labs(x="longitude", y= paste0("PC1",percentage[1])) +
  geom_text_repel(data=subset(pc_info, country %in% c("United States", "Netherlands", "Poland", "Russia", "Sweden")), aes(x=longitude, y=PC1, label = sample_name), max.overlaps = 50, size = 2)

# save plot
ggsave(paste0(temp_plot, "nyc_neu_pca1Long_zoom.png"), nyc_neu_pc1Long_zoom, height = 5, width = 8)
```

```{r}
nyc_neu_pc1Lat_zoom <- ggplot() +
  geom_point(data=subset(pc_info, country %in% c("United States", "Netherlands", "Poland", "Russia", "Sweden")), aes(x=PC2, y=latitude, color = country)) +
  theme_bw() +
  labs(x=paste0("PC2",percentage[2]), y= "latitude") +
  geom_text_repel(data=subset(pc_info, country %in% c("United States", "Netherlands", "Poland", "Russia", "Sweden")), aes(x=PC2, y=latitude, label = sample_name), max.overlaps = 50, size = 2)

# save plot
ggsave(paste0(temp_plot, "nyc_neu_pca1Lat_zoom.png"), nyc_neu_pc1Lat_zoom, height = 5, width = 8)
```

Yeah, I would say so!

```{r}
# rough plot
nyc_neu_pc_plot2 <- ggplot() +
  geom_point(data=pc_info, aes(x=PC1, y=PC3, color = country)) +
  theme_bw() +
  labs(x=paste0("PC1",percentage[1]), y= paste0("PC3",percentage[3])) +
  geom_text_repel(data=subset(pc_info, country != "United States"), aes(x=PC1, y=PC3, label = sample_name), max.overlaps = 50, size = 2)

nyc_neu_pc_plot2
```


```{r}
# rough plot
nyc_neu_pc_plot3 <- ggplot() +
  geom_point(data=pc_info, aes(x=PC2, y=PC3, color = country)) +
  theme_bw() +
  labs(x=paste0("PC2",percentage[2]), y= paste0("PC3",percentage[3])) +
  geom_text_repel(data=subset(pc_info, country != "United States"), aes(x=PC2, y=PC3, label = sample_name), max.overlaps = 50, size = 2)

nyc_neu_pc_plot3
```

Let's just plot NYC samples on a map.
```{r}
ny_map +
  geom_point(data = subset(pc_info, country = "United States"), aes(x=longitude, y = latitude, color = city))
  
```
The N. European cluster without NYC included is only 22 samples. PLINK will perform PCA with less than 50 samples without being given an allele frequency file because the sample number is too low. I think I should still be able to convert the pruned VCF to bed files and do the conditional ADMIXTURE analysis.

I do not know if that will give me any additional useful information, however. Given how the PCA looks, it seems pretty clear that the NYC samples are most similar to Polish, Russian and Swedish populations, with the New Jersey population being the closest. 

Also, Northern Chinese populations cluster together, while the sample from northeastern China clusters with the sample from Reykjavik.

# Write populations to file
At this point, it makes sense to generate a key for generalized population structure to use in other analyses.
Specifically, I am going to use these population groups in the PIXY analyses, and other explorations of comparisons between the populations at the local genomic scale.

Here, I just plan to combine the population keys generated above. I consider the conditional analysis to reflect the truest and most probable population structure.

The most useful and informative clustering is when K=3, so I will use that to define clusters

```{r}
# create descriptive column for ancestral range population groups
k3Pops <- ea_k3_ancestryL %>% mutate(k3population = case_when(group == "pop1" ~ "N_Europe",
                                                         group == "pop2" ~ "E_Asia",
                                                         group == "pop3" ~ "MENA"))
```

Now I will write the data population data to file
```{r save cbp population file, eval=FALSE}
write.table(k3Pops[c("vcf_sample_name","sample_name","k3population", "latitude", "longitude", "latlong_approx")], file = "~/Documents/PhD/Research/capsella_population_structure/cbp_pop_str.txt", col.names = T, row.names = F, quote = F, sep = "\t")
```
